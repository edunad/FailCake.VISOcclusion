#pragma kernel CullPortals
//#pragma enable_d3d11_debug_symbols

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

// -----------------------------------------------------------------------
// STRUCTS & CONSTANTS ----------------------------------
// -----------------------------------------------------------------------
struct PortalComputeDataGPU
{
    float4x4 localToWorld;
    float4 data; // x = portalType, y = status, z = unused, w = unused
};

#define PORTAL_STATUS_PENDING 0.0
#define PORTAL_STATUS_VISIBLE 1.0
#define PORTAL_STATUS_CLOSED 2.0

#define PORTAL_TYPE_2D 1
#define PORTAL_TYPE_3D 2

// -----------------------------------------------------------------------
// BUFFERS & VARIABLES ----------------------------------
// -----------------------------------------------------------------------
RWStructuredBuffer<PortalComputeDataGPU> _PortalDataBuffer;
TEXTURE2D(_VISDepthTexture);
// -----------------------------------------------------------------------
// -----------------------------------------------------------------------

float4 _OcclusionParams; // sample, depth, padding, total
#define PORTAL_SAMPLES (uint)_OcclusionParams.x
#define DEPTH_BIAS _OcclusionParams.y
#define PORTAL_PADDING _OcclusionParams.z
#define TOTAL_PORTALS (uint)_OcclusionParams.w

// -----------------------------------------------------------------------
// -----------------------------------------------------------------------

bool IsPointVisible(float2 uv, float portalLinearDepth)
{
    if (any(saturate(uv) != uv) || portalLinearDepth <= 0.001)
        return false;

    float sceneDepthRaw = SAMPLE_TEXTURE2D_LOD(_VISDepthTexture, sampler_PointClamp, uv, 0).r;
    #if defined(UNITY_REVERSED_Z)
    if (sceneDepthRaw <= 0.00001) return true;
    #else
    if (sceneDepthRaw >= 0.99999) return true;
    #endif

    float sceneLinearDepth = LinearEyeDepth(sceneDepthRaw, _ZBufferParams);
    return sceneLinearDepth > portalLinearDepth - DEPTH_BIAS;
}

// -----------------------------------------------------------------------
// MAIN KERNEL ----------------------------------
// -----------------------------------------------------------------------

[numthreads(64, 1, 1)]
void CullPortals(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    if (index >= TOTAL_PORTALS) return;

    PortalComputeDataGPU portal = _PortalDataBuffer[index];
    if (portal.data.y != PORTAL_STATUS_PENDING) return;

    // DEFAULT ------------------------------------------
    portal.data.y = PORTAL_STATUS_CLOSED;
    // -----------------------------------------------------------------------

    // -----------------------------------------------------------------------
    // SETUP
    // -----------------------------------------------------------------------

    float3 corners[8];
    float depths[4] = {-1.0, -1.0, -1.0, -1.0};

    float2 minBounds = float2(1e10, 1e10);
    float2 maxBounds = float2(-1e10, -1e10);

    uint planeOutsideMask = 0x3F;
    bool is3DPortal = portal.data.x == PORTAL_TYPE_3D;

    if (is3DPortal)
    {
        corners[0] = mul(portal.localToWorld, float4(-0.5, -0.5, -0.5, 1.0)).xyz;
        corners[1] = mul(portal.localToWorld, float4(0.5, -0.5, -0.5, 1.0)).xyz;
        corners[2] = mul(portal.localToWorld, float4(-0.5, 0.5, -0.5, 1.0)).xyz;
        corners[3] = mul(portal.localToWorld, float4(0.5, 0.5, -0.5, 1.0)).xyz;
        corners[4] = mul(portal.localToWorld, float4(-0.5, -0.5, 0.5, 1.0)).xyz;
        corners[5] = mul(portal.localToWorld, float4(0.5, -0.5, 0.5, 1.0)).xyz;
        corners[6] = mul(portal.localToWorld, float4(-0.5, 0.5, 0.5, 1.0)).xyz;
        corners[7] = mul(portal.localToWorld, float4(0.5, 0.5, 0.5, 1.0)).xyz;
    }
    else
    {
        corners[0] = mul(portal.localToWorld, float4(-0.5, -0.5, 0.0, 1.0)).xyz; // BL
        corners[1] = mul(portal.localToWorld, float4(0.5, -0.5, 0.0, 1.0)).xyz; // BR
        corners[2] = mul(portal.localToWorld, float4(-0.5, 0.5, 0.0, 1.0)).xyz; // TL
        corners[3] = mul(portal.localToWorld, float4(0.5, 0.5, 0.0, 1.0)).xyz; // TR
    }

    uint numCorners = is3DPortal ? 8 : 4;

    UNITY_LOOP
    for (uint c = 0; c < numCorners; ++c)
    {
        float3 worldPos = corners[c];

        UNITY_UNROLLX(6)
        for (uint plane = 0; plane < 6; ++plane)
        {
            float dist = dot(unity_CameraWorldClipPlanes[plane].xyz, worldPos) + unity_CameraWorldClipPlanes[plane].w;
            if (dist >= 0.0) planeOutsideMask &= ~(1u << plane);
        }

        if (!is3DPortal && c < 4)
        {
            float4 clipPos = mul(UNITY_MATRIX_VP, float4(worldPos, 1.0));

            if (clipPos.w > 0.001)
            {
                float2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;
                #if UNITY_UV_STARTS_AT_TOP
                screenUV.y = 1.0 - screenUV.y;
                #endif

                minBounds = min(minBounds, screenUV);
                maxBounds = max(maxBounds, screenUV);

                depths[c] = clipPos.w;
            }
        }
    }

    if (planeOutsideMask != 0)
    {
        _PortalDataBuffer[index] = portal;
        return;
    }

    if (is3DPortal)
    {
        portal.data.y = PORTAL_STATUS_VISIBLE;
        _PortalDataBuffer[index] = portal;
        return;
    }

    // --- QUICK TESTS (2D ONLY)  ---
    // -----------------------------------------------------------------------
    float2 padding = PORTAL_PADDING * (maxBounds - minBounds);
    minBounds = saturate(minBounds - padding);
    maxBounds = saturate(maxBounds + padding);

    float2 screenSize = maxBounds - minBounds;

    if (IsPointVisible((minBounds + maxBounds) * 0.5, (depths[0] + depths[1] + depths[2] + depths[3]) * 0.25))
    {
        portal.data.y = PORTAL_STATUS_VISIBLE;
        _PortalDataBuffer[index] = portal;
        return;
    }


    if (IsPointVisible(minBounds, depths[0]) ||
        IsPointVisible(float2(maxBounds.x, minBounds.y), depths[1]) ||
        IsPointVisible(float2(minBounds.x, maxBounds.y), depths[2]) ||
        IsPointVisible(maxBounds, depths[3]))
    {
        portal.data.y = PORTAL_STATUS_VISIBLE;
        _PortalDataBuffer[index] = portal;
        return;
    }

    float2 centerUV = (minBounds + maxBounds) * 0.5;
    if (IsPointVisible(float2(centerUV.x, minBounds.y), (depths[0] + depths[1]) * 0.5) ||
        IsPointVisible(float2(maxBounds.x, centerUV.y), (depths[1] + depths[3]) * 0.5) ||
        IsPointVisible(float2(centerUV.x, maxBounds.y), (depths[2] + depths[3]) * 0.5) ||
        IsPointVisible(float2(minBounds.x, centerUV.y), (depths[0] + depths[2]) * 0.5))
    {
        portal.data.y = PORTAL_STATUS_VISIBLE;
        _PortalDataBuffer[index] = portal;
        return;
    }

    // -----------------------------------------------------------------------
    // --- SAMPLING ---

    static const float2 R2_ALPHA = float2(0.7548776662466927, 0.5698402909980532);
    uint seed = index ^ asuint(_Time.y);

    seed = seed ^ 61u ^ seed >> 16u;
    seed *= 9u;
    seed ^= seed >> 4u;
    seed *= 0x27d4eb2du;

    float2 baseJitter = float2(seed, seed ^ seed >> 11u) * (1.0 / 4294967296.0);
    for (uint idx = 0; idx < PORTAL_SAMPLES; ++idx)
    {
        float2 r2 = frac(float2(idx, idx) * R2_ALPHA + baseJitter);
        float spread = idx / (float)PORTAL_SAMPLES;

        float2 centered = r2 * 2.0 - 1.0;
        centered = sign(centered) * (1.0 - sqrt(1.0 - abs(centered)));
        float2 gridPos = lerp(float2(0.5, 0.5), centered * 0.5 + 0.5, spread);

        float2 sampleUV = minBounds + gridPos * screenSize;

        float sampleDepth = lerp(
            lerp(depths[0], depths[1], gridPos.x),
            lerp(depths[2], depths[3], gridPos.x),
            gridPos.y
        );

        if (IsPointVisible(sampleUV, sampleDepth))
        {
            portal.data.y = PORTAL_STATUS_VISIBLE;
            _PortalDataBuffer[index] = portal;
            return;
        }
    }
    // -----------------------------------------------------------------------
    _PortalDataBuffer[index] = portal;
}

/*# MIT License Copyright (c) 2025 FailCake

# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*/